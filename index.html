<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>갓파큘라를 잡아라! (보스 패턴 수정)</title>

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kjy76-inhatc.github.io/kong/">
    <meta property="og:title" content="갓파큘라를 잡아라_신규출시">
    <meta property="og:description" content="지금 플레이하세요!">
    <meta property="og:image" content="https://kjy76-inhatc.github.io/kong/op01.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="갓파큘라를 잡아라_신규출시">
    <meta name="twitter:description" content="지금 플레이하세요!">
    <meta name="twitter:image" content="https://kjy76-inhatc.github.io/kong/op01.png">

    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; width: 100%; height: 100vh; }
        canvas { display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); max-width: 100%; max-height: 100%; width: 100%; height: 100%; object-fit: contain; z-index: 1; }
        .hint { position: fixed; top: 10px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.7); font-size: 12px; font-weight: bold; pointer-events: none; z-index: 10; text-shadow: 1px 1px 2px black; }

        .controls-layer { position: fixed; bottom: 20px; left: 0; width: 100%; height: auto; display: flex; justify-content: space-between; padding: 0 20px; box-sizing: border-box; pointer-events: none; z-index: 999; }
        .control-group { display: flex; gap: 15px; align-items: flex-end; pointer-events: auto; }
        .btn { width: 65px; height: 65px; background: rgba(255, 255, 255, 0.15); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; color: rgba(255, 255, 255, 0.8); font-size: 20px; font-weight: bold; display: flex; justify-content: center; align-items: center; user-select: none; -webkit-user-select: none; backdrop-filter: blur(2px); }
        .btn:active, .btn.pressed { background: rgba(255, 255, 255, 0.5); transform: scale(0.9); }
        .btn-atk { background: rgba(255, 50, 50, 0.2); border-color: rgba(255, 50, 50, 0.4); width: 75px; height: 75px; font-size: 16px; }
        @media (orientation: landscape) { .controls-layer { bottom: 10px; padding: 0 40px; } }
    </style>
</head>
<body>

<canvas id="cv" width="960" height="540"></canvas>
<div class="hint">PC: 방향키/스페이스바 | 모바일: 가로모드 권장</div>

<div class="controls-layer">
    <div class="control-group">
        <div class="btn" id="btn-left">◀</div>
        <div class="btn" id="btn-right">▶</div>
    </div>
    <div class="control-group">
        <div class="btn btn-atk" id="btn-atk">ATK</div>
        <div class="btn" id="btn-jump">JUMP</div>
    </div>
</div>

<audio id="bgm" src="좀비 코인 넣어!.mp3" loop></audio>
<audio id="bossBgm" src="죽지 않는 왕.mp3" loop></audio>
<audio id="gameOverBgm" src="좀비게인, 게임 오버 발라드.mp3"></audio>

<audio id="sfxAttack" src="yapp.mp3"></audio>
<audio id="sfxHit" src="acc.mp3"></audio>
<audio id="sfxJump" src="jump.mp3"></audio>
<audio id="sfxBossOut" src="bossout.mp3"></audio>

<script>
const cv = document.getElementById("cv");
const g = cv.getContext("2d");

const W = 960;
const H = 540;
const GROUND_Y = 500; 
const MAP_LEN = W * 3; 

const images = {
  intro: new Image(),
  bg: new Image(),
  player: new Image(),
  playerDead: new Image(), 
  npc: new Image(),
  enemy: new Image(),
  boss: new Image(), 
  bossDead: new Image(),
  enemyDead: new Image(),
  ball: new Image()
};

images.intro.src = 'image_22.png';
images.bg.src = 'stage01.png';
images.player.src = 'image_0.png'; 
images.playerDead.src = 'image_38.png';
images.npc.src = 'image_7.png';
images.enemy.src = '갓파.png';
images.boss.src = 'boss01.png'; 
images.bossDead.src = 'boss02.png';
images.enemyDead.src = '갓파2.png';
images.ball.src = 'ball.png';

let gameState = "intro"; 
let stageStep = 0; 
let camX = 0;
let enemies = []; 
let bossBalls = []; 
let totalEnemies = 49; 
let killCount = 0; 
let enemiesSpawned = 0; 
let spawnTimer = 0;     
let bossSpawned = false; 

let gameTime = 300; 
let frameCount = 0; 

const player = {
  x: 100, y: GROUND_Y, 
  vx: 0, vy: 0,
  speed: 6, jumpPower: -17, gravity: 0.8,
  onGround: true, facing: 1, 
  attackTimer: 0,
  hp: 50, maxHp: 50, atk: 5,
  hurtTimer: 0,
  scale: 0.25 
};

const npc = {
  x: -200, y: GROUND_Y, facing: -1, speed: 5, active: false
};

function playSound(id) {
    const audio = document.getElementById(id);
    if(audio) {
        audio.currentTime = 0; 
        audio.play().catch(() => {});
    }
}

// ■ 보스 공 클래스 (유도 기능 추가)
class BossBall {
    constructor(x, y, targetX, targetY) {
        this.x = x;
        this.y = y; 
        this.radius = 20;
        this.speed = 8; // 공 속도
        this.damage = 5; 
        this.active = true;
        this.rotation = 0;

        // 플레이어 방향으로 벡터 계산 (조준)
        const dx = targetX - x;
        const dy = (targetY - 40) - y; // 플레이어 몸통 쪽을 향해 발사
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        // 정규화 후 속도 적용
        this.vx = (dx / distance) * this.speed;
        this.vy = (dy / distance) * this.speed;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.rotation += 0.2; // 회전 효과

        // 맵이나 화면 밖으로 너무 멀리 나가면 삭제
        if (this.x < camX - 200 || this.x > camX + W + 200 || this.y > H + 200 || this.y < -500) {
            this.active = false;
        }
    }

    draw() {
        const screenX = this.x - camX;
        g.save();
        g.translate(screenX, this.y);
        g.rotate(this.rotation);
        if(images.ball.complete && images.ball.naturalWidth !== 0) {
            g.drawImage(images.ball, -this.radius, -this.radius, this.radius*2, this.radius*2);
        } else {
            g.beginPath();
            g.arc(0, 0, this.radius, 0, Math.PI*2);
            g.fillStyle = "red";
            g.fill();
            g.strokeStyle = "yellow";
            g.lineWidth = 2;
            g.stroke();
        }
        g.restore();
    }
}

class Kappa {
  constructor(isBoss = false) {
    this.isBoss = isBoss;
    this.ballTimer = 0; 
    this.respawn(true);
  }

  respawn(firstSpawn = false) {
    if (this.isBoss && bossSpawned) return; 

    const minSpawnX = 500;
    const startX = minSpawnX + Math.random() * (MAP_LEN - minSpawnX - 100);
    
    this.x = startX;
    this.y = GROUND_Y;
    this.state = "alive"; 
    this.deathTimer = 0; 
    this.facing = Math.random() < 0.5 ? -1 : 1; 

    if (this.isBoss) {
        this.hp = 100; this.maxHp = 100; 
        this.atk = 5; 
        // ■ 보스 속도 하향 (6 -> 3) : 이제 따라잡을 수 있습니다.
        this.speed = 3; 
        this.scale = 0.5 / 3; 
        this.ballTimer = 60; 
        bossSpawned = true;
    } else {
        this.hp = 10; this.maxHp = 10;
        this.atk = 2;
        this.speed = 2 + Math.random() * 2;
        this.scale = 0.25; 
    }
  }

  update() {
    if (this.state === "dead") return;

    if (this.state === "dying") {
      this.deathTimer--;
      if (this.deathTimer <= 0) {
        this.state = "dead";
        if (this.isBoss) gameState = "stageClear";
      }
      return;
    }

    this.x += this.speed * this.facing;

    if (this.x < 100) {
        this.x = 100;
        this.facing = 1; 
    } else if (this.x > MAP_LEN - 100) {
        this.x = MAP_LEN - 100;
        this.facing = -1; 
    }

    // ■ 보스 조준 발사 로직
    if (this.isBoss && this.state === "alive") {
        this.ballTimer--;
        if (this.ballTimer <= 0) {
            // 보스 위치에서 플레이어 위치(player.x, player.y)를 향해 발사
            // 발사 위치는 보스의 약간 위쪽 (y - 60)
            bossBalls.push(new BossBall(this.x, this.y - 60, player.x, player.y));
            
            // 공격 간격 (약 1.5초 ~ 2.5초)
            this.ballTimer = 90 + Math.random() * 60; 
        }
    }
  }

  takeDamage(dmg) {
    if (this.state !== "alive") return;
    this.hp -= dmg;
    playSound("sfxHit");

    if (this.hp <= 0) {
      this.hp = 0;
      this.state = "dying";
      this.deathTimer = 60;
      
      if (this.isBoss) {
          playSound("sfxBossOut");
      }

      if (!this.isBoss) {
          killCount++;
          if (killCount >= totalEnemies) { 
              gameState = "bossReady";
              enemies = []; 
          }
      }
    }
  }
}

function initEnemies() {
  enemies = [];
  bossBalls = [];
  killCount = 0;
  enemiesSpawned = 0;
  spawnTimer = 0; 
  bossSpawned = false;
}

function spawnBoss() {
    enemies = [];
    bossBalls = [];
    enemies.push(new Kappa(true)); 
}

const keys = {};

function resetGame() {
    gameState = "intro";
    player.hp = player.maxHp;
    player.x = 100; player.y = GROUND_Y;
    gameTime = 300;
    
    initEnemies();
    npc.active = false;
    document.body.classList.remove("ingame");
    
    stopAllMusic();
    tryPlayMusic("bgm");
}

function stopAllMusic() {
    const bgm = document.getElementById("bgm");
    const bossBgm = document.getElementById("bossBgm");
    const overBgm = document.getElementById("gameOverBgm"); 
    if(bgm) { bgm.pause(); bgm.currentTime = 0; }
    if(bossBgm) { bossBgm.pause(); bossBgm.currentTime = 0; }
    if(overBgm) { overBgm.pause(); overBgm.currentTime = 0; }
}

function tryPlayMusic(id) {
    stopAllMusic(); 
    const audio = document.getElementById(id);
    if(audio) {
        audio.volume = 0.5;
        audio.play().catch(() => {});
    }
}

window.addEventListener("keydown", (e) => {
  if(["ArrowUp", "ArrowDown", "Space", " "].includes(e.key)) e.preventDefault();
  handleInput(e.key, true);
});

window.addEventListener("keyup", (e) => {
  handleInput(e.key, false);
});

function bindTouch(btnId, keyName) {
    const btn = document.getElementById(btnId);
    btn.addEventListener("touchstart", (e) => { e.preventDefault(); btn.classList.add("pressed"); handleInput(keyName, true); }, {passive: false});
    btn.addEventListener("touchend", (e) => { e.preventDefault(); btn.classList.remove("pressed"); handleInput(keyName, false); }, {passive: false});
    btn.addEventListener("mousedown", (e) => { btn.classList.add("pressed"); handleInput(keyName, true); });
    btn.addEventListener("mouseup", (e) => { btn.classList.remove("pressed"); handleInput(keyName, false); });
}

bindTouch("btn-left", "ArrowLeft");
bindTouch("btn-right", "ArrowRight");
bindTouch("btn-jump", "ArrowUp");
bindTouch("btn-atk", "Space");

function handleInput(key, isPressed) {
    let k = key;
    if(key === " " || key === "Space") k = "Space";

    if(isPressed) keys[k] = true;
    else keys[k] = false;

    if(k === "Space" && isPressed) {
        if (gameState === "intro") {
            gameState = "stageStart";
            stageStep = 0; 
            tryPlayMusic("bgm");
        } 
        else if(gameState === "stageStart") {
            if(stageStep === 0) {
                stageStep = 1; 
                npc.x = player.x + 200; 
                npc.active = true;
            } else if(stageStep === 1) {
                stageStep = 2; 
            }
        }
        else if (gameState === "bossReady") {
            gameState = "bossFight";
            player.hp = player.maxHp; 
            spawnBoss();
            tryPlayMusic("bossBgm");
        }
        else if (gameState === "gameOver") {
            resetGame();
        }
    }
}

function update() {
  if (gameState === "intro" || gameState === "gameOver" || gameState === "stageClear" || gameState === "bossReady") return;

  if (gameState === "stageStart") {
    if(stageStep === 2) {
        npc.x -= npc.speed; 
        if(npc.x < -100) {
            gameState = "play";
            npc.active = false;
            document.body.classList.add("ingame");
            initEnemies(); 
        }
    }
    return;
  }

  if (gameState === "play" || gameState === "bossFight") {
      frameCount++;
      if (frameCount % 60 === 0) { 
          gameTime--;
          if (gameTime <= 0) {
              gameTime = 0;
              player.hp = 0; 
          }
      }

      if (gameState === "play" && enemiesSpawned < totalEnemies) {
          spawnTimer--;
          if (spawnTimer <= 0) {
              const k = new Kappa(false);
              enemies.push(k);
              enemiesSpawned++;
              let nextTime = 120 - (enemiesSpawned * 2);
              if (nextTime < 30) nextTime = 30;
              spawnTimer = nextTime;
          }
      }
  }

  if (player.hp <= 0) {
      gameState = "gameOver";
      tryPlayMusic("gameOverBgm"); 
      return;
  }

  player.vx = 0;
  if (keys["ArrowLeft"]) { player.vx = -player.speed; player.facing = -1; }
  if (keys["ArrowRight"]) { player.vx = player.speed; player.facing = 1; }
  player.x += player.vx;

  if (keys["ArrowUp"]) {
    if (player.y >= GROUND_Y - 10) {
      player.vy = player.jumpPower; player.y -= 5; player.onGround = false;
      playSound("sfxJump");
    }
  }

  if ((keys["Space"]) && player.attackTimer === 0) {
      player.attackTimer = 15;
      playSound("sfxAttack");
  }
  
  if (player.attackTimer > 0) player.attackTimer--;

  player.vy += player.gravity; player.y += player.vy;
  if (player.y >= GROUND_Y) { player.y = GROUND_Y; player.vy = 0; player.onGround = true; }
  
  if (player.x < 30) player.x = 30;
  if (player.x > MAP_LEN - 30) player.x = MAP_LEN - 30;

  camX = player.x - W / 2;
  if (camX < 0) camX = 0;
  if (camX > MAP_LEN - W) camX = MAP_LEN - W;

  if (player.hurtTimer > 0) player.hurtTimer--;

  bossBalls.forEach((ball, index) => {
      ball.update();
      if(!ball.active) {
          bossBalls.splice(index, 1);
          return;
      }
      if (player.hurtTimer === 0) {
          // 공 충돌 판정
          if (ball.x > player.x - 20 && ball.x < player.x + 20 &&
              ball.y > player.y - 60 && ball.y < player.y + 10) {
              
              player.hp -= ball.damage;
              player.hurtTimer = 60;
              player.vy = -5;
              // 공이 온 방향으로 튕겨나감
              player.x += (ball.vx > 0 ? 20 : -20);
              ball.active = false; 
          }
      }
  });

  enemies.forEach(enemy => {
    enemy.update();
    if(enemy.state === "dead") return;

    // 1. 배트 공격
    if(player.attackTimer > 0 && player.attackTimer < 12 && enemy.state === "alive") {
       const rangeBonus = enemy.isBoss ? 50 : 0;
       const atkRange = 100 + rangeBonus; 
       const dist = (enemy.x - player.x) * player.facing;
       if(dist > 0 && dist < atkRange && Math.abs(enemy.y - player.y) < 60 + rangeBonus) {
          enemy.takeDamage(player.atk);
          player.attackTimer = 0; 
       }
    }

    // 2. 밟기 공격
    let isStomping = false;
    if (player.vy > 0 && enemy.state === "alive" && player.hurtTimer === 0) {
        const stompWidth = enemy.isBoss ? 40 : 30; 
        if (Math.abs(player.x - enemy.x) < stompWidth) {
            if (player.y < enemy.y - 20 && player.y > enemy.y - 100) {
                enemy.takeDamage(10); 
                player.vy = -10; 
                isStomping = true;
            }
        }
    }

    // 3. 플레이어 피격
    if(!isStomping && enemy.state === "alive" && player.hurtTimer === 0) {
       const hitBonus = enemy.isBoss ? 30 : 0;
       if(Math.abs(player.x - enemy.x) < 40 + hitBonus && Math.abs(player.y - enemy.y) < 50 + hitBonus) {
          player.hp -= enemy.atk;
          player.hurtTimer = 60; 
          player.vy = -5; 
          player.x -= player.facing * 20;
          if(player.hp < 0) player.hp = 0;
       }
    }
  });
}

function drawHPBar(x, y, hp, maxHp, width, color, isFixed=false, offset=90) {
    if(isFixed) {
        g.fillStyle = "black";
        g.fillRect(x, y, width, 15);
        g.fillStyle = color;
        const hpW = (hp / maxHp) * width;
        g.fillRect(x, y, hpW, 15);
        g.strokeStyle = "white"; g.lineWidth = 2;
        g.strokeRect(x, y, width, 15);
    } else {
        const barY = y - offset;
        g.fillStyle = "black";
        g.fillRect(x - width/2, barY, width, 6);
        g.fillStyle = color;
        const hpW = (hp / maxHp) * width;
        g.fillRect(x - width/2, barY, hpW, 6);
        g.strokeStyle = "white"; g.lineWidth = 1;
        g.strokeRect(x - width/2, barY, width, 6);
    }
}

function drawCharacter(img, x, y, facing, angle=0, alpha=1, scale=0.25, isDeadEnemy=false) {
    if (!img.complete || img.naturalWidth === 0) return;
    g.save();
    g.globalAlpha = alpha;
    
    let finalScale = scale;
    if (isDeadEnemy) {
        if (img.src.includes("boss")) {
             finalScale = scale * 3.0; 
        } else {
             finalScale = scale * 0.2;
        }
    }

    const w = img.width * finalScale;
    const h = img.height * finalScale;

    g.translate(x, y); 
    
    if (img.src.includes("boss") || img.src.includes("갓파")) {
        g.scale(-facing, 1);
    } else {
        g.scale(facing, 1); 
    }

    g.translate(0, -h/2);
    g.rotate(angle);
    g.translate(0, h/2);
    g.drawImage(img, -w/2, -h, w, h);
    g.restore();
}

function draw() {
  g.clearRect(0, 0, W, H);

  if (gameState === "intro") {
    if (images.intro.complete) g.drawImage(images.intro, 0, 0, W, H);
    return;
  }

  if (images.bg.complete) {
    const bgX = -(camX * 0.5) % W;
    g.drawImage(images.bg, bgX, 0, W, H);
    if (bgX < 0) g.drawImage(images.bg, bgX + W, 0, W, H);
  } else { g.fillStyle = "#87ceeb"; g.fillRect(0,0,W,H); }
  g.fillStyle = "#654321"; g.fillRect(0, GROUND_Y, W, H - GROUND_Y);
  g.fillStyle = "#4ec04e"; g.fillRect(0, GROUND_Y, W, 10);

  if (gameState === "gameOver") {
      g.fillStyle = "rgba(0,0,0,0.8)"; g.fillRect(0,0,W,H);
      if(images.playerDead.complete) {
        drawCharacter(images.playerDead, W/2, H/2 + 100, 1, 0, 1, player.scale);
      }
      g.fillStyle = "red"; g.textAlign = "center"; g.font = "bold 60px sans-serif";
      g.fillText("GAME OVER", W/2, H/2 - 50);
      g.fillStyle = "white"; g.font = "24px sans-serif";
      g.fillText("터치하여 다시 시작", W/2, H/2);
      return;
  }

  if (gameState === "stageClear") {
      g.fillStyle = "rgba(0,0,0,0.8)"; g.fillRect(0,0,W,H);
      g.fillStyle = "yellow"; g.textAlign = "center"; g.font = "bold 60px sans-serif";
      g.fillText("STAGE ONE CLEAR!", W/2, H/2);
      return;
  }

  bossBalls.forEach(ball => ball.draw());

  enemies.forEach(enemy => {
    const screenX = enemy.x - camX;
    
    if (screenX < -200 || screenX > W + 200) return;
    if (enemy.state === "dead") return;

    let img;
    if (enemy.state === "dying") {
        img = enemy.isBoss ? images.bossDead : images.enemyDead;
    } else {
        img = enemy.isBoss ? images.boss : images.enemy;
    }
    const isDead = (enemy.state === "dying");

    if (img.complete) {
        drawCharacter(img, screenX, enemy.y, enemy.facing, 0, 1, enemy.scale, isDead); 
    } else {
        g.fillStyle = "green"; g.fillRect(screenX-25, enemy.y-50, 50, 50);
    }

    if (enemy.state === "alive") {
        const barWidth = enemy.isBoss ? 100 : 50;
        const hpOffset = enemy.isBoss ? 120 : 110; 
        drawHPBar(screenX, enemy.y, enemy.hp, enemy.maxHp, barWidth, "red", false, hpOffset);
    }
  });

  const screenX = player.x - camX;
  let atkAngle = 0;
  if (player.attackTimer > 0) atkAngle = (player.attackTimer > 10) ? -0.5 : 1.0;
  let pAlpha = (player.hurtTimer > 0 && Math.floor(player.hurtTimer / 4) % 2 === 0) ? 0.5 : 1;

  if(images.player.complete) {
      drawCharacter(images.player, screenX, player.y, player.facing, atkAngle, pAlpha, player.scale);
  } else {
      g.fillStyle = "blue"; g.fillRect(screenX-20, player.y-60, 40, 60);
  }

  if (player.attackTimer > 0) {
    g.save(); g.translate(screenX, player.y - 40); g.scale(player.facing, 1);
    g.beginPath(); g.strokeStyle = "white"; g.lineWidth = 5; g.arc(0, 0, 60, -1, 1); g.stroke();
    g.restore();
  }

  if (gameState === "stageStart") {
    if (npc.active && images.npc.complete) drawCharacter(images.npc, npc.x - camX, npc.y, npc.facing, 0, 1, player.scale);
    if (stageStep === 0) { g.fillStyle="rgba(0,0,0,0.7)";g.fillRect(0,0,W,H);g.fillStyle="white";g.textAlign="center";g.font="bold 60px sans-serif";g.fillText("STAGE ONE",W/2,H/2-30);g.font="bold 40px sans-serif";g.fillText("갓파큘라를 잡아라!",W/2,H/2+40);g.font="20px sans-serif";g.fillText("▼ 터치 또는 스페이스바",W/2,H-100);}
    else if(stageStep===1){g.fillStyle="rgba(0,0,0,0.8)";g.fillRect(0,0,W,160);g.fillStyle="#444";g.fillRect(30,20,120,35);g.fillStyle="white";g.textAlign="center";g.font="bold 20px sans-serif";g.fillText("여학생",90,45);g.textAlign="left";g.font="24px sans-serif";g.fillText("도시가 갓파에게 점령당했어요!",50,90);g.fillText("갓파를 물리치고 탈출할 수 있는 항구로 가세요.",50,130);g.textAlign="right";g.font="16px sans-serif";g.fillStyle="#aaa";g.fillText("▶ Next",W-30,140);}
  }

  if (gameState === "bossReady") {
      g.fillStyle = "rgba(0,0,0,0.7)"; g.fillRect(0,0,W,H);
      g.fillStyle = "red"; g.textAlign = "center"; g.font = "bold 60px sans-serif";
      g.fillText("⚠️ STAGE BOSS ⚠️", W/2, H/2 - 20);
      g.fillStyle = "white"; g.font = "30px sans-serif";
      g.fillText("HP가 회복되었습니다!", W/2, H/2 + 40);
      g.font = "20px sans-serif"; g.fillText("터치하면 보스전 시작", W/2, H - 100);
  }

  if (gameState === "play" || gameState === "bossFight") {
      const minutes = Math.floor(gameTime / 60);
      const seconds = Math.floor(gameTime % 60);
      const timeStr = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
      g.fillStyle = "white"; g.font = "bold 24px sans-serif"; g.textAlign = "center";
      g.fillText(`⏱ TIME: ${timeStr}`, W/2, 30);
      
      g.textAlign = "left";
      g.fillStyle = "white"; g.font = "bold 20px sans-serif"; 
      g.fillText("PLAYER HP", 20, 25);
      drawHPBar(20, 35, player.hp, player.maxHp, 200, "#00ff00", true);

      if(gameState === "play") {
          g.fillText(`남은 적: ${totalEnemies - killCount}마리`, 240, 50);
      }
  }
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>